{"name":"Muster","tagline":"A library for macro based serializers to many different formats","body":"# Muster\r\n\r\nA library for macro based serializers to different formats.\r\nIt uses scala macros so no reflection is involved and it will generate code at compile time\r\nthat kind of looks like it would have been handwritten.  It is written with the idea of extension, so it's easy to\r\nadd your own formats.\r\n\r\nYou can find the [documentation on the wiki](https://github.com/json4s/muster/wiki)\r\n\r\n## Getting the library\r\n\r\nThis only works with scala 2.11.\r\nThe library is published to maven central so you can get it with:\r\n\r\n```\r\nlibraryDependencies += \"org.json4s\" %% \"muster-codec-jawn\" % \"0.2.0\"\r\nlibraryDependencies += \"org.json4s\" %% \"muster-codec-jackson\" % \"0.2.0\"\r\n```\r\n\r\nBring your own AST (BYA):\r\n\r\n```\r\nlibraryDependencies += \"org.json4s\" %% \"muster-codec-json4s\" % \"0.2.0\"\r\n```\r\n\r\nPrettier case class for debugging:\r\n\r\n```scala\r\nlibraryDependencies += \"org.json4s\" %% \"muster-codec-string\" % \"0.2.0\"\r\n```\r\n\r\n## How does it work?\r\n\r\nYou can find the [documentation on the wiki](https://github.com/json4s/muster/wiki)\r\nThe idea is that things work a little bit like this:\r\n\r\n### Writing\r\n\r\n```scala\r\ncase class Person(id: Long, name: String, age: Int)\r\nval person = Person(1, \"Luke\", 38)\r\n\r\nimport muster.codec.jawn._\r\nJsonFormat.from(person)\r\nJsonFormat.into(new File(\"luke.json\")).from(person)\r\nJsonFormat.Pretty.from(person)\r\n\r\nimport muster.codec.jawn.api._\r\nperson.asJson // calls: JsonFormat.from(person) and produces {\"id\":1,\"name\":\"Luke\",\"age\":38}\r\nperson.asPrettyJson /* calls: JsonFormat.Pretty.from(person) and produces\r\n                       {\r\n                         \"id\":1,\r\n                         \"name\":\r\n                         \"Luke\",\r\n                         \"age\":38\r\n                       } */\r\n\r\n\r\nimport muster.codec.json4s._\r\n// decompose to a Json4s AST\r\nJValueFormat.from(person)\r\n\r\nimport muster.codec.json4s.api._\r\nperson.asJValue\r\n\r\n\r\n// Serialize Json4s AST's\r\nimport muster.codec.json4s._\r\nJsonFormat.into(new File(\"jvalues.json\")).from(person.asJValue)\r\nJsonFormat.Pretty.from(person.asJValue)\r\n\r\n// Prettier string formatting of case classes\r\nimport muster.codec.string._\r\nStringFormat.from(person)\r\n\r\nimport muster.codec.string.api._\r\nperson.asString \r\n// calls muster.codec.string.api.StringFormat.from(person) \r\n// and produces Person(id: 1, name: \"Luke\", age: 38)\r\n\r\n\r\n```\r\n\r\n### Reading\r\n\r\nSimilarly reading can be achieved with\r\n\r\n```scala\r\n// Extract a person from a json stream\r\nimport muster.codec.jawn._\r\nJsonFormat.as[Person](/* file | string | reader | byte array | input stream | URL */ input)\r\n\r\n// Extract a person from a Json4s AST\r\nimport muster.codec.json4s._\r\nJValueFormat.as[Person](personJValue)\r\n\r\n// Parse a source to a Json4s AST\r\nimport muster.codec.json4s._\r\nJsonFormat.as[JValue](/* file | string | reader | byte array | input stream | URL */ input)\r\n```\r\n\r\n## What's inside?\r\n\r\nSeamless integration with the Json4s AST, it can be used to extract objects from and decompose objects to json4s AST's.\r\nIt can be used to parse Json4s AST's \r\n\r\nCurrently muster supports JSON through parsing with jackson or jawn and it can extract the following things:\r\n\r\nObject mapping features:\r\n* Primitive values like String, Int, Date\r\n* All scala collections\r\n* Scala maps with string keys\r\n* Java collections like java.util.List and java.util.Set\r\n* Java maps (that implement java.util.Map)\r\n* Java classes with bean getter/setters\r\n* Scala classes with public vars\r\n* Scala classes with java style getter/setter methods\r\n* Scala case classes\r\n* Classes initialized through a constructor only\r\n* Classes with type parameters\r\n* Support for maps with different keys than String\r\n* Allows choosing between different option treatments for formats that support omission instead of null\r\n\r\nPossibly added next:\r\n* Support for scala enums\r\n* Support for java enums\r\n* Support for renaming fields \r\n* Support for using a map as an input source\r\n* Support for serializing and deserializing from mongodb\r\n* Provide a way to use custom producibles\r\n* Provide a way to use custom consumables\r\n* Support for common annotations like @JsonProperty and so on to provide overrides for behavior\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}